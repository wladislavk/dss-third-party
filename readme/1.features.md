Features
========

Feature files are written using Gherkin language. The specification of Gherkin syntax
can be obtained [here](https://cucumber.io/docs/reference#gherkin). Gherkin is not a programming language and can be used with
any programming language.

Gherkin looks "almost" like English, but there are two important points in Gherkin
semantics that distinguish it from plain English text, these are reusability
and idempotency.

1) Reusability. The strongest point of Gherkin text, as compared to plain xUnit,
is reusability, it ensures that on a sufficiently big codebase test code will be
much less verbose than if writing non-reusable Gherkin. In order to make Gherkin reusable,
use quoted variables as much as possible. For example, instead of writing
```
When the page loads
Then I see submit button
When I click submit button
Then the form submits
```

you can write this:
```
When the page loads
Then I see "submit" button
When I click "submit" button
Then the form submits
```

This way, the same Gherkin can be reused for a different page where the button
is called something different, e.g. "Go". In fact, this Gherkin can (and should)
be used for ANY button in the application. IDEs give helpers for Gherkin lines
that look similar to existing lines, use them.

2) Idempotency. Having non-idempotent lines is the single most often occurring
mistake when writing Gherkin. In common speech, lines tend to depend on previous lines.
For example, take this Gherkin:
```
When the page loads
Then I see submit button
When I click this button
Then the form submits
```

Here line 3 depends on line 2. If we delete line 2, line 3 would make no sense
because it is unclear which button we are talking about. Another common example
of non-idempotent lines concerns AND operator:

```
Then I see submit button
And it is red
```

Obviously, these two lines cannot be swapped places.

Idempotency means that every line must make sense if other lines would not exist.
"When A and B" must be equivalent to "When B and A". Non-idempotent Gherkin
is not reusable because it means we cannot reuse this line in a different scenario.

Scenario length
---------------

Unlike unit tests, that normally should be short, acceptance tests can be pretty
long for the sake of performance. The rule of thumb on where to divide a scenario
into parts is: one scenario should correspond to actions of one user in a single
part of the application where session variables are shared. So, normally a single
feature should have one scenario per test user, e.g. one for normal user, one
for admin, one for anonymous. If more than one user needs to be guided through
absolutely identical steps, such as testing i18n features for users with different
locales, scenario outlines should be used.

Specificity
-----------

Acceptance tests should be as non-specific as possible, meaning the complete
lack of technicalities. Put it like this: a 10-year-old kid should be able to
understand feature file contents.

Bad example:
```
Scenario: Test that JWT token is generated properly
Given user called "foo" exists
When user "foo" requires page "/hello"
Then a JWT token gets appended to the query string in AJAX call
Given user called "bar" does not exist
When user "bar" requires page "/hello"
Then no JWT token gets appended to the query string in AJAX call
```

Good example:
```
Scenario: Test user authentication
Given user called "foo" exists
When user "foo" requires page "/hello"
Then they see a welcome page
Given user called "bar" does not exist
When user "bar" requires page "/hello"
Then they see "403" error
```

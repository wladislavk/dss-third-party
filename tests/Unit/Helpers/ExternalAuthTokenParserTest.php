<?php

namespace Tests\Unit\Helpers;

use DentalSleepSolutions\StaticClasses\SudoHelper;
use Tests\TestCases\UnitTestCase;
use DentalSleepSolutions\Helpers\ExternalAuthTokenParser;
use DentalSleepSolutions\Eloquent\Repositories\Dental\ExternalCompanyRepository;
use DentalSleepSolutions\Eloquent\Repositories\Dental\ExternalUserRepository;
use DentalSleepSolutions\Eloquent\Repositories\UserRepository;
use DentalSleepSolutions\Eloquent\Models\User;

class ExternalAuthTokenParserTest extends UnitTestCase
{
    const EMPTY_TOKEN = '';
    const COMPANY_TOKEN = 'company_key';
    const USER_TOKEN = 'user_key';
    const INVALID_COMPANY_TOKEN = 'company_invalid_token';
    const INVALID_USER_TOKEN = 'user_invalid_token';

    const USER_ID = 1;
    const USER_VIEW_ID = SudoHelper::USER_PREFIX . self::USER_ID;
    
    /** @var ExternalAuthTokenParser */
    private $tokenParser;

    /** @var string|null */
    private $companyWhereConditional;

    /** @var string|null */
    private $userWhereConditional;

    public function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->mockAuthToken();
    }

    /**
     * @dataProvider tokenDataProvider
     */
    public function testTokens($perCaseDescription, $companyToken, $userToken, $userData)
    {
        $user = $this->tokenParser->getUserData($companyToken, $userToken);
        $this->assertEquals($userData, $user, $perCaseDescription);
    }

    public function tokenDataProvider()
    {
        return [
            [
                'Missing company key',
                self::EMPTY_TOKEN,
                self::USER_TOKEN,
                null
            ],
            [
                'Missing user key',
                self::COMPANY_TOKEN,
                self::EMPTY_TOKEN,
                null
            ],
            [
                'Invalid company key',
                self::INVALID_COMPANY_TOKEN,
                self::USER_TOKEN,
                null
            ],
            [
                'Invalid user key',
                self::COMPANY_TOKEN,
                self::INVALID_USER_TOKEN,
                null
            ],
            [
                'Valid company/user keys',
                self::COMPANY_TOKEN,
                self::USER_TOKEN,
                $this->mockUser()
            ],
        ];
    }

    private function mockAuthToken()
    {
        $this->tokenParser = new ExternalAuthTokenParser(
            $this->mockExternalCompanyRepository(),
            $this->mockExternalUserRepository(),
            $this->mockUserRepository()
        );
    }

    public function mockUser()
    {
        $user = new User();
        $user->user_id = self::USER_ID;
        $user->id = self::USER_ID;
        $user->admin = 0;

        return $user;
    }

    public function mockUserView()
    {
        $user = $this->mockUser();
        $user->id = self::USER_VIEW_ID;

        return $user;
    }

    private function mockExternalCompanyRepository()
    {
        $mock = \Mockery::mock(ExternalCompanyRepository::class);
        $this->companyWhereConditional = null;

        $mock->shouldReceive('findWhere')
            ->with(\Mockery::anyOf(
                ['api_key' => self::EMPTY_TOKEN],
                ['api_key' => self::COMPANY_TOKEN],
                ['api_key' => self::INVALID_COMPANY_TOKEN]
            ))
            ->atMost()
            ->times(1)
            ->andReturnUsing(function ($fieldValue) use ($mock) {
                $this->companyWhereConditional = $fieldValue;
                return $mock;
            });

        $mock->shouldReceive('first')
            ->atMost()
            ->times(1)
            ->andReturnUsing(function () {
                if ($this->companyWhereConditional === ['api_key' => self::COMPANY_TOKEN]) {
                    return true;
                }

                return false;
            });

        return $mock;
    }

    private function mockExternalUserRepository()
    {
        $repository = \Mockery::mock(ExternalUserRepository::class);
        $this->userWhereConditional = null;

        $repository->shouldReceive('findWhere')
            ->with(\Mockery::anyOf(
                ['api_key' => self::EMPTY_TOKEN],
                ['api_key' => self::USER_TOKEN],
                ['api_key' => self::INVALID_USER_TOKEN]
            ))
            ->atMost()
            ->times(1)
            ->andReturnUsing(function ($fieldValue) use ($repository) {
                $this->userWhereConditional = $fieldValue;
                return $repository;
            });

        $repository->shouldReceive('first')
            ->atMost()
            ->times(1)
            ->andReturnUsing(function () {
                if ($this->userWhereConditional === ['api_key' => self::USER_TOKEN]) {
                    return $this->mockUserView();
                }

                return null;
            });

        return $repository;
    }

    private function mockUserRepository()
    {
        $repository = \Mockery::mock(UserRepository::class);

        $repository->shouldReceive('find')
            ->with(self::USER_VIEW_ID)
            ->atMost()
            ->times(1)
            ->andReturnSelf();

        $repository->shouldReceive('first')
            ->atMost()
            ->times(1)
            ->andReturn($this->mockUser());

        return $repository;
    }
}

# 3.5.1. Associative arrays are dangerous

PHP gives coders great liberty in using arrays, which often leads to coders using arrays
where they should not be used. While there are cases for using associative arrays,
a coder SHOULD be very cautious each time an associative array is created.

Associative arrays SHOULD NOT be used except in following cases:
1) a class constant, since in PHP no other non-scalar value can be a constant;
2) as a return value of a method if the result is used by the framework, such as
passing the array to a Blade template;
3) as an argument for a called method of a framework or a third-party library, when
an array is required.

In all other cases, structs or models SHOULD be used (see 3.5.2).

Whenever possible, a coder SHOULD ensure type-safety of all arrays, meaning that
all array elements SHOULD have the same type.

In all instances when an array element is required, there MUST be a check for the
element's existence using `isset()`, `empty()` or `array_key_exists()`. Naturally, these
checks MUST be unit-tested as any other conditional. When an array is returned by an Eloquent
model, the element MAY NOT be checked (see 4.1.1).

If an array is received as an argument, there MUST be a type check either via a type hint or 
using `is_array()` before `foreach` operator is used. The same applies to method calls that
may return something other than an array. Type hints SHOULD be used in place of `is_array()`
when possible.

Element order in associative arrays MUST NOT be relied upon unless a sorting function
is used in the same class.
 
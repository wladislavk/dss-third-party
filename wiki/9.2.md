# 9.2. What to test and what not to test

The most difficult question when working on acceptance tests is - what should we test? Unlike unit tests
and functional tests, acceptance tests do not conform to any strict standard regarding the scope of testing.
The general rule is: test for the things that are different between two states and are perceived to be important.
If the management descends feature files to the team, it is evident that they will include things they
perceive as important. If coders write feature files themselves, they SHOULD include things they perceive
of having some value to an average user.

Acceptance tests SHOULD be as non-specific as possible, meaning the complete lack of technicalities. Put it 
like this: a 10-year-old kid should be able to understand feature file contents. Technicalities MAY appear
in contexts, but not in feature files, so if you decide to test how the DB state will change after some
user action - think again, perhaps this test will look better in the functional suite, while in acceptance
we can only measure the presentation of this DB state to users. 

Requirements for acceptance tests become more strict when a test is written as a part of a bugfix. If a bug
affects user experience in a testable way, a new test MUST be written that will fail with the bug present
but will pass otherwise, so it needs to be specifically targeted to the area where the bug happens.

Things that usually get acceptance-tested are:
- authentication and authorization
- navigation
- form submission and validation.

Unfortunately, there are things that are difficult or impossible to acceptance-test even though they do
influence user experience, among them:
- BOM objects that are not related to the request-response cycle, such as `window.alert`, `window.confirm`
  and others that belong to `window` object but not to `document` object
- HTTP basic authentication
- e-mails
- images and media files generated by scripts
- functionality that relies on mouse movement.
